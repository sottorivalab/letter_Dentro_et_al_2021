---
title: "Clustering à la PCWAG"
author: "Salvatore Milite"
output:   
  rmdformats::downcute:
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: false
    highlight: tango
---

We discuss here PCAWG consensus clustering, re-implemented in simpler form.

# Motivation

An automatic runnable  pipeline was never released by PCAWG; therefore, the best we could achieve was a re-implementation of part of it. In order to reproduce the very same pipelines we have found missing details regarding model selection procedures (e.g., with CliP),  specific inputs  to build the files used for clustering (e.g., with Sclust), and other general limitations. 

We opted then to run 2 tools with binomial likelihood and one with beta-binomial likelihood, which is  a similar ratio to the original pipeline (2 vs 7 methods). 

Here we chose:

* [Pyclone-VI](https://github.com/Roth-Lab/pyclone-vi) (beta-binomial), a variational extension of the Markov Chain Monte Carlo [Pyclone](https://github.com/Roth-Lab/pyclone)
* [Ccube](https://github.com/keyuan/ccube) (normal-binomial)
* [DPclust](https://github.com/Wedge-lab/dpclust) (binomial)

For these methods, we could follow the tool documentation and, at least, run à la PCAWG analysis on simulated data.

**Versioning.** To avoid versioning issues the packages used were included in the code bundle; this markdown does not run this installation code.

```{r, eval = FALSE}
### Unzip the source code for the packages
unzip("PCAWG_tools.zip", overwrite = T)
```

Install Ccube (in R).
```{r, eval = FALSE}
devtools::install_local("ccube/")
```

Install DPClust (in R).
```{r, eval = FALSE}
devtools::install_local("ccube/")
```

Install PyClone-VI (via shell, with mini/anaconda).
```{bash, eval = FALSE}
# We assume you have mini/anaconda installed, for more information please refer to the pyclone-vi README
cd pyclone-vi

# Environment, create and activate
conda create -c conda-forge -n pyclone-vi --file requirements.txt --yes
source activate pyclone-vi

# Installation
pip install git+https://github.com/Roth-Lab/pyclone-vi.git

cd ..
```
**Other required packages.**

```{r, message=FALSE, results='hide', echo=FALSE}
set.seed(1234)

# Used packages
require(dplyr)
require(readr)
library(tidyverse, quietly = TRUE)

# Models
require(VGAM)
require(ccube)
require(mclust)
require(fpc)
require(matrixStats)

# Plots
library(patchwork)
require(ggplot2)
require(cowplot)

# Weme source code
source("../weme.R")
```

# Example dataset

We generated a simulated dataset assuming:

- a negative binomial density;
- coverage $50$;
- overdispersion $\rho=0.015$. 
- a mnoclonal tumour, i.e., with just the clonal cluster;
- $65\%$ purity. 

All these values are well representative of the PCAWG data quality.

```{r}
# Parameters
MEAN_COV <- 45
RHO <- 0.015
N <- 5000
purity  <-  0.65
```

Synthetic read-counts.
```{r}
# Poisson-distributed coverage
DP <-  rpois(N, MEAN_COV)

# Beta-Binomial reads with the variant
NV <- rbetabinom(N, size = DP, prob = 0.5 * purity, rho = RHO)

# Random genomic coordinates
chr <- rep(1, N)
position <- sample.int(1e8, size = N, replace = T) %>% sort()

# Data
inp <-  data.frame(chr, position, DP, NV, VAF = NV /DP)
save(inp, file = "input_data.rda")

```
Synthetic data plots
```{r}
hist(DP)
hist(NV)
hist(NV/DP) # VAF
```

# Ccube analysis (normal-binomial, variational)

We run ccube as in the vignette with 5 repetitions

```{r, eval = FALSE}
numOfClusterPool = 1:6
numOfRepeat = 5

# Format
ccube_inp <- data.frame(
  major_cn = 1,
  minor_cn = 1,
  total_cn = 2,
  purity = purity,
  n
  ormal_cn = 1,
  mutation_id = paste(chr, position, sep = "_"),
  var_counts = NV,
  ref_counts = DP - NV,
  total_counts = DP
) %>% as_tibble()

# Fit
results_ccube <- RunCcubePipeline(
  ssm = ccube_inp,
  numOfClusterPool = numOfClusterPool,
  numOfRepeat = numOfRepeat,
  runAnalysis = T,
  runQC = T
)

# Save results
save(results_ccube, file = "results_ccube.rda")
```

Inspect results - standard Ccube visualisation. Recall that there should be only 1 single-cluster in this deconvolution.
```{r}
load("results_ccube.rda")

MakeCcubeStdPlot(ssm = results_ccube$ssm, res = results_ccube$res)
```

# DPClust analysis (binomial, Monte Carlo)

Prepare inputs.

```{r}
dir.create("dpclust_input", showWarnings = FALSE)

data.frame(
  chr = chr,
  end = position,
  Reference_Allele = "A", # Made up, do not affect results
  Tumor_Seq_Allele2 = "T",
  mut.count	 = NV,
  WT.count = DP - NV,
  subclonal.CN	 = 2,
  mutation.copy.number	 = 1,
  subclonal.fraction	 = 1,
  no.chrs.bearing.mut	= 1
) %>%
  readr::write_tsv(., "dpclust_input/sample0_input.txt")

data.frame(
  sample = "sample0",
  subsample = "01",
  datafile = "./sample0_input.txt",
  cellularity = purity
) %>%
  readr::write_tsv(., "dpclust_input/sample0.txt")
```

For DPClust we use the pipeline that can be found in the package, it is also available as a docker image. The code below is not run by this markdown.

```{bash, eval = FALSE}
mkdir -p output_dpclust
cd dpclust/inst/example

R --vanilla --slave -q -f dpclust_pipeline.R --args -r 1 -d ../../../dpclust_input/ -o ../../../output_dpclust -i ../../../dpclust_input/sample0.txt

```

Assemble results, and print outputs.
```{r}
cluster_composition_dpclust <-
  readr::read_tsv(
    "output_dpclust/sample0_DPoutput_2000iters_1000burnin_seed123/sample0_2000iters_1000burnin_bestClusterInfo.txt",
    col_types = cols()
  )

print(cluster_composition_dpclust)
```

# Pyclone-VI analysis (beta-binomial, variational)

Create inputs.
```{r}
dir.create("pyclone_input", showWarnings = F)

data.frame(
  mutation_id = paste0("S_", 1:length(DP)), # indifferent
  sample_id = "example",
  alt_counts	 = NV,
  ref_counts = DP - NV,
  normal_cn	 = 2,
  major_cn	 = 1,
  minor_cn	= 1,
  tumour_content = purity
) %>%
  readr::write_tsv(., "pyclone_input/sample0_input.tsv")
```

Fit is run through the conda environment previously created. We use miniforge on a macbook with M1 processor; this should point to your conda init script.
```{bash,eval = FALSE}
source ~/miniforge3/etc/profile.d/conda.sh

conda activate pyclone-vi

mkdir output_pyclone

pyclone-vi fit -i pyclone_input/sample0_input.tsv -o output_pyclone/example.h5 -c 40 -d beta-binomial -r 10

pyclone-vi write-results-file -i output_pyclone/example.h5 -o output_pyclone/example.tsv
```

# WeMe consensus clustering

We  prepare the inputs; we retain only clusters with $>50$ mutations.

**Method 1: CCube.**

```{r, results = FALSE}
dir.create("example_simulated", showWarnings = F)

# Method 1 - Ccube
dir.create("example_simulated/method1", showWarnings = F)

load("results_ccube.rda", verbose = T)

results_ccube$ssm$cluster_id <- results_ccube$res$label
ccube_sc = results_ccube$ssm %>% 
  group_by(cluster_id) %>% 
  summarise(
    n_ssms = n(), 
    proportion = ccube_ccf_mean %>%  unique()
    ) %>%  
  rename(cluster = cluster_id) %>%  
  select(cluster, n_ssms, proportion) %>%  
  mutate(proportion = proportion * purity)

readr::write_tsv(
  "example_simulated/method1/example_subclonal_structure.txt",
  x = ccube_sc %>%  
    filter(n_ssms > 50) %>%  
    arrange(-proportion) %>% 
    mutate(cluster = 1:length(cluster))
  )
```

**Method 2: DPClust**

```{r, eval=FALSE}
dir.create("example_simulated/method2", showWarnings = F)

## dpclust apparently returns the location in terms of total tumour cells so we multiply it by purity
dpclust_sc <-  cluster_composition_dpclust %>%  
  rename(
    cluster = cluster.no, 
    proportion = location, 
    n_ssms = no.of.mutations) %>%  
  mutate(proportion= proportion * purity) %>% 
  select(cluster, n_ssms, proportion)

readr::write_tsv(
  "example_simulated/method2/example_subclonal_structure.txt", 
  x = dpclust_sc %>%  
    filter(n_ssms > 50) %>%  
    arrange(-proportion) %>% 
    mutate(cluster = 1:length(cluster))
  )
```

**Method 3: Pyclone-VI**

```{r, eval=FALSE}
dir.create("example_simulated/method3", showWarnings = F)

pyclone_out <-
  readr::read_tsv("output_pyclone/example.tsv", col_types = cols()) %>%
  group_by(cluster_id, cellular_prevalence) %>%  
  summarize(n_ssms = n())

pyclone_sc <- pyclone_out %>%  
  rename(cluster = cluster_id, proportion = cellular_prevalence) %>%  
  select(cluster, n_ssms, proportion) %>%
  mutate(proportion = proportion * purity)

readr::write_tsv(
  "example_simulated/method3/example_subclonal_structure.txt",
  x = pyclone_sc %>%  
    filter(n_ssms > 50) %>%  
    arrange(-proportion) %>% 
    mutate(cluster = 1:length(cluster))
)
```



From WeMe inputs we see that Pyclone-VI clusters the data in a single cluster, if we exclude an extremely small cluster on the left tail of the distribution. 
```{r}
read.table(file = "./method3/example_subclonal_structure.txt", header = T)
```
However, the  other algorithms push to fragment the clonal cluster into $>1$ clusters, leading to an error with respect to the starting generative model (monoclonal).
```{r}
read.table(file = "./method1/example_subclonal_structure.txt", header = T)
read.table(file = "./method2/example_subclonal_structure.txt", header = T)
```

We compute the consensus.
```{r}
setwd("example_simulated/")

# WeMe
sids = find_sids()
genconsensus(sids,rounddown=FALSE)

# WeMe
read.table(file = "./example_subclonal_structure.txt", header = T)
```

We can plot the results as in Supplementary Figure S2.

```{r, message=FALSE, results='hide'}
# load_input
load("input_data.rda", verbose = T)

# Heterozygous diploid mutations
inp$CCF <-  inp$VAF * 2

# load ccube fit 
load("results_ccube.rda", verbose = T)
inp$ccube_clusters <- results_ccube$res$label

# load dpclust
dpclust_res <-  readr::read_tsv("output_dpclust/sample0_DPoutput_2000iters_1000burnin_seed123/sample0_2000iters_1000burnin_bestConsensusAssignments.bed")
inp$dpclust_clusters <- dpclust_res$cluster

#load pyclone-vi fit
pyclone_res <- readr::read_tsv("output_pyclone/example.tsv")
inp$pyclone_res <- pyclone_res$cluster_id + 1

#load consensus
consensus_structure <- readr::read_tsv("example_simulated/example_subclonal_structure.txt")
```

We can assign mutations to the WeMw output assuming that they come from a beta-binomial mixture model.

```{r}
RHO = 0.01

# Posterior clustering assignments
lk_c1 <-
  VGAM::dbetabinom(
    x = inp$NV,
    size = inp$DP ,
    prob = consensus_structure$proportion[1] / 2,
    log = T,
    rho = RHO
  ) + log(consensus_structure$n_ssms[1] / 100) 

lk_c2 <-
  VGAM::dbetabinom(
    x = inp$NV,
    size = inp$DP ,
    prob = consensus_structure$proportion[2] / 2,
    log = T,
    rho = RHO
  ) + log(consensus_structure$n_ssms[2] / 100)


# Hard clusterings
inp$consensus_cluster <- apply(
  cbind(lk_c1, lk_c2), 
  MARGIN = 1, 
  FUN = function(x) which.max(x)
  )
```

Example plots with all algorithms at once.
```{r}
df_b <- inp %>% 
  select(
    CCF, 
    ccube_clusters, 
    dpclust_clusters, 
    pyclone_res, 
    consensus_cluster) %>%  
  rename(
    weme = consensus_cluster, 
    pyclone = pyclone_res, 
    ccube = ccube_clusters, 
    dpclust = dpclust_clusters) %>% 
  reshape2::melt(id.vars = "CCF")

# Plot
ggplot(df_b, 
       aes(x = CCF, fill = value %>% paste())
       ) + 
  geom_histogram(binwidth = 0.02) + 
  scale_fill_brewer("Cluster", palette = "Set2") + 
  facet_wrap(.~variable, nrow = 1) + 
  theme_bw() + ggtitle("Clustering assignments simulation")
```

![WeMe consensus](example_simulated/example.png)

# Multiple simulations (generalisation)

We provide code to reproduce the actual simulations with more replicates (not run here):

```{bash, eval=FALSE}
Rscript run_simulation.R
```

This will generate $10$ folders named `sim_[1-NREPS]` with all the inputs and results, together with  file `p_sim.rds` to plot  panel  Supplementary Figure S2c. 

After running the example code above, together with the simulation in the vignette *Clustering simulations*, the last command to generate Supplementary Figure S2

```{bash, eval = FALSE}
Rscript figure_S2.R
```


![Supplementary Figure S2](figure_S2.png)
